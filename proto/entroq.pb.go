// Code generated by protoc-gen-go.
// source: entroq.proto
// DO NOT EDIT!

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	entroq.proto

It has these top-level messages:
	TaskID
	TaskData
	TaskChange
	Task
	QueueStats
	ClaimRequest
	ClaimResponse
	ModifyRequest
	ModifyResponse
	ModifyDep
	TasksRequest
	TasksResponse
	QueuesRequest
	QueuesResponse
	TimeRequest
	TimeResponse
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type DepType int32

const (
	DepType_CLAIM  DepType = 0
	DepType_DELETE DepType = 1
	DepType_CHANGE DepType = 2
	DepType_DEPEND DepType = 3
	DepType_DETAIL DepType = 4
	DepType_INSERT DepType = 5
)

var DepType_name = map[int32]string{
	0: "CLAIM",
	1: "DELETE",
	2: "CHANGE",
	3: "DEPEND",
	4: "DETAIL",
	5: "INSERT",
}
var DepType_value = map[string]int32{
	"CLAIM":  0,
	"DELETE": 1,
	"CHANGE": 2,
	"DEPEND": 3,
	"DETAIL": 4,
	"INSERT": 5,
}

func (x DepType) String() string {
	return proto1.EnumName(DepType_name, int32(x))
}
func (DepType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// TaskID contains the ID and version of a task. Together these make a unique
// identifier for that task.
type TaskID struct {
	Id      string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Version int32  `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
}

func (m *TaskID) Reset()                    { *m = TaskID{} }
func (m *TaskID) String() string            { return proto1.CompactTextString(m) }
func (*TaskID) ProtoMessage()               {}
func (*TaskID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *TaskID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TaskID) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

// TaskData contains only the data portion of a task. Useful for insertion.
type TaskData struct {
	// The name of the queue for this task.
	Queue string `protobuf:"bytes,1,opt,name=queue" json:"queue,omitempty"`
	// The epoch time in millis when this task becomes available.
	AtMs int64 `protobuf:"varint,2,opt,name=at_ms,json=atMs" json:"at_ms,omitempty"`
	// The task's opaque payload.
	Value []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// An optional ID (UUID) for an inserted task to use.
	// Default is for the backend to assign one, and that is sufficient for many
	// cases. If you desire to make a database entry that *references* a task,
	// however, in that case it can make sense to specify an explicit task ID for
	// insertion (allowing "consume -> db update -> modify" worker cycles to
	// safely update a database entry that references to-be-inserted tasks).
	Id string `protobuf:"bytes,4,opt,name=id" json:"id,omitempty"`
}

func (m *TaskData) Reset()                    { *m = TaskData{} }
func (m *TaskData) String() string            { return proto1.CompactTextString(m) }
func (*TaskData) ProtoMessage()               {}
func (*TaskData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TaskData) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *TaskData) GetAtMs() int64 {
	if m != nil {
		return m.AtMs
	}
	return 0
}

func (m *TaskData) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TaskData) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// TaskChange identifies a task by ID and specifies the new data it should contain.
// All fields should be filled in. Empty fields result in deleting data from that field.
type TaskChange struct {
	OldId   *TaskID   `protobuf:"bytes,1,opt,name=old_id,json=oldId" json:"old_id,omitempty"`
	NewData *TaskData `protobuf:"bytes,2,opt,name=new_data,json=newData" json:"new_data,omitempty"`
}

func (m *TaskChange) Reset()                    { *m = TaskChange{} }
func (m *TaskChange) String() string            { return proto1.CompactTextString(m) }
func (*TaskChange) ProtoMessage()               {}
func (*TaskChange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TaskChange) GetOldId() *TaskID {
	if m != nil {
		return m.OldId
	}
	return nil
}

func (m *TaskChange) GetNewData() *TaskData {
	if m != nil {
		return m.NewData
	}
	return nil
}

// Task is a complete task object, containing IDs, data, and metadata.
type Task struct {
	// The name of the queue for this task.
	Queue   string `protobuf:"bytes,1,opt,name=queue" json:"queue,omitempty"`
	Id      string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Version int32  `protobuf:"varint,3,opt,name=version" json:"version,omitempty"`
	// The epoch time in millis when this task becomes available.
	AtMs int64 `protobuf:"varint,4,opt,name=at_ms,json=atMs" json:"at_ms,omitempty"`
	// The UUID representing the claimant (owner) for this task.
	ClaimantId string `protobuf:"bytes,5,opt,name=claimant_id,json=claimantId" json:"claimant_id,omitempty"`
	// The task's opaque payload.
	Value []byte `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
	// Epoch times in millis for creation and update of this task.
	CreatedMs  int64 `protobuf:"varint,7,opt,name=created_ms,json=createdMs" json:"created_ms,omitempty"`
	ModifiedMs int64 `protobuf:"varint,8,opt,name=modified_ms,json=modifiedMs" json:"modified_ms,omitempty"`
	// The number of times this has been successfully claimed.
	Claims int32 `protobuf:"varint,9,opt,name=claims" json:"claims,omitempty"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto1.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Task) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *Task) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Task) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Task) GetAtMs() int64 {
	if m != nil {
		return m.AtMs
	}
	return 0
}

func (m *Task) GetClaimantId() string {
	if m != nil {
		return m.ClaimantId
	}
	return ""
}

func (m *Task) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Task) GetCreatedMs() int64 {
	if m != nil {
		return m.CreatedMs
	}
	return 0
}

func (m *Task) GetModifiedMs() int64 {
	if m != nil {
		return m.ModifiedMs
	}
	return 0
}

func (m *Task) GetClaims() int32 {
	if m != nil {
		return m.Claims
	}
	return 0
}

// QueueStats contains the name of the queue and the number of tasks within it.
type QueueStats struct {
	Name     string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	NumTasks int32  `protobuf:"varint,2,opt,name=num_tasks,json=numTasks" json:"num_tasks,omitempty"`
}

func (m *QueueStats) Reset()                    { *m = QueueStats{} }
func (m *QueueStats) String() string            { return proto1.CompactTextString(m) }
func (*QueueStats) ProtoMessage()               {}
func (*QueueStats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *QueueStats) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueueStats) GetNumTasks() int32 {
	if m != nil {
		return m.NumTasks
	}
	return 0
}

// ClaimRequest is sent to attempt to claim a task from a queue. The claimant ID
// should be unique to the requesting worker (e.g., if multiple workers are in
// the same process, they should all have different claimant IDs assigned).
type ClaimRequest struct {
	// The party requesting a task.
	ClaimantId string `protobuf:"bytes,1,opt,name=claimant_id,json=claimantId" json:"claimant_id,omitempty"`
	// The queue names to claim a task from.
	Queues []string `protobuf:"bytes,2,rep,name=queues" json:"queues,omitempty"`
	// The duration of the claim, if/once successful.
	DurationMs int64 `protobuf:"varint,3,opt,name=duration_ms,json=durationMs" json:"duration_ms,omitempty"`
	// How long to sleep for a claim (not try claim) between polls. The sleep may be interruptible depending on the backend implementation.
	PollMs int64 `protobuf:"varint,4,opt,name=poll_ms,json=pollMs" json:"poll_ms,omitempty"`
}

func (m *ClaimRequest) Reset()                    { *m = ClaimRequest{} }
func (m *ClaimRequest) String() string            { return proto1.CompactTextString(m) }
func (*ClaimRequest) ProtoMessage()               {}
func (*ClaimRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ClaimRequest) GetClaimantId() string {
	if m != nil {
		return m.ClaimantId
	}
	return ""
}

func (m *ClaimRequest) GetQueues() []string {
	if m != nil {
		return m.Queues
	}
	return nil
}

func (m *ClaimRequest) GetDurationMs() int64 {
	if m != nil {
		return m.DurationMs
	}
	return 0
}

func (m *ClaimRequest) GetPollMs() int64 {
	if m != nil {
		return m.PollMs
	}
	return 0
}

// ClaimResponse is returned when a claim is fulfilled or becomes obviously impossible.
//
// For TryClaim calls, if no task is available, the task will be empty and the
// status code sent to the client will be OK.
//
// For Claim calls, the lack of a task is an error, usually a timeout or
// cancelation.
type ClaimResponse struct {
	Task *Task `protobuf:"bytes,1,opt,name=task" json:"task,omitempty"`
}

func (m *ClaimResponse) Reset()                    { *m = ClaimResponse{} }
func (m *ClaimResponse) String() string            { return proto1.CompactTextString(m) }
func (*ClaimResponse) ProtoMessage()               {}
func (*ClaimResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ClaimResponse) GetTask() *Task {
	if m != nil {
		return m.Task
	}
	return nil
}

// ModifyRequest sends a request to modify a set of tasks with given
// dependencies. It is performed in a transaction, in which either all
// suggested modifications succeed and all dependencies are satisfied, or
// nothing is committed at all. A failure due to dependencies (in any
// of changes, deletes, or inserts) will be permanent.
//
// All successful changes will cause the requester to become the claimant.
type ModifyRequest struct {
	ClaimantId string        `protobuf:"bytes,1,opt,name=claimant_id,json=claimantId" json:"claimant_id,omitempty"`
	Inserts    []*TaskData   `protobuf:"bytes,2,rep,name=inserts" json:"inserts,omitempty"`
	Changes    []*TaskChange `protobuf:"bytes,3,rep,name=changes" json:"changes,omitempty"`
	Deletes    []*TaskID     `protobuf:"bytes,4,rep,name=deletes" json:"deletes,omitempty"`
	Depends    []*TaskID     `protobuf:"bytes,5,rep,name=depends" json:"depends,omitempty"`
}

func (m *ModifyRequest) Reset()                    { *m = ModifyRequest{} }
func (m *ModifyRequest) String() string            { return proto1.CompactTextString(m) }
func (*ModifyRequest) ProtoMessage()               {}
func (*ModifyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ModifyRequest) GetClaimantId() string {
	if m != nil {
		return m.ClaimantId
	}
	return ""
}

func (m *ModifyRequest) GetInserts() []*TaskData {
	if m != nil {
		return m.Inserts
	}
	return nil
}

func (m *ModifyRequest) GetChanges() []*TaskChange {
	if m != nil {
		return m.Changes
	}
	return nil
}

func (m *ModifyRequest) GetDeletes() []*TaskID {
	if m != nil {
		return m.Deletes
	}
	return nil
}

func (m *ModifyRequest) GetDepends() []*TaskID {
	if m != nil {
		return m.Depends
	}
	return nil
}

// ModifyResponse returns inserted and updated tasks when successful.
// A dependency error (which is permanent) comes through as gRPC's NOT_FOUND code.
type ModifyResponse struct {
	Inserted []*Task `protobuf:"bytes,1,rep,name=inserted" json:"inserted,omitempty"`
	Changed  []*Task `protobuf:"bytes,2,rep,name=changed" json:"changed,omitempty"`
}

func (m *ModifyResponse) Reset()                    { *m = ModifyResponse{} }
func (m *ModifyResponse) String() string            { return proto1.CompactTextString(m) }
func (*ModifyResponse) ProtoMessage()               {}
func (*ModifyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ModifyResponse) GetInserted() []*Task {
	if m != nil {
		return m.Inserted
	}
	return nil
}

func (m *ModifyResponse) GetChanged() []*Task {
	if m != nil {
		return m.Changed
	}
	return nil
}

// ModifyDep can be returned with a gRPC NotFound status indicating which
// dependencies failed. This is done via the gRPC error return, not directly
// in the response proto.
type ModifyDep struct {
	Type DepType `protobuf:"varint,1,opt,name=type,enum=proto.DepType" json:"type,omitempty"`
	Id   *TaskID `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Msg  string  `protobuf:"bytes,3,opt,name=msg" json:"msg,omitempty"`
}

func (m *ModifyDep) Reset()                    { *m = ModifyDep{} }
func (m *ModifyDep) String() string            { return proto1.CompactTextString(m) }
func (*ModifyDep) ProtoMessage()               {}
func (*ModifyDep) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ModifyDep) GetType() DepType {
	if m != nil {
		return m.Type
	}
	return DepType_CLAIM
}

func (m *ModifyDep) GetId() *TaskID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ModifyDep) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// TasksRequest is sent to request a complete listing of tasks for the
// given queue. If claimant_id is empty, all tasks (not just expired
// or owned tasks) are returned.
type TasksRequest struct {
	ClaimantId string `protobuf:"bytes,1,opt,name=claimant_id,json=claimantId" json:"claimant_id,omitempty"`
	Queue      string `protobuf:"bytes,2,opt,name=queue" json:"queue,omitempty"`
	Limit      int32  `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`
	// If IDs are specified here, then any task which matches any of these IDs,
	// and simultaneously fits other specifications, will be returned.
	// If empty, all tasks that fit other specifications will be returned.
	TaskId []string `protobuf:"bytes,4,rep,name=task_id,json=taskId" json:"task_id,omitempty"`
}

func (m *TasksRequest) Reset()                    { *m = TasksRequest{} }
func (m *TasksRequest) String() string            { return proto1.CompactTextString(m) }
func (*TasksRequest) ProtoMessage()               {}
func (*TasksRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *TasksRequest) GetClaimantId() string {
	if m != nil {
		return m.ClaimantId
	}
	return ""
}

func (m *TasksRequest) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *TasksRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *TasksRequest) GetTaskId() []string {
	if m != nil {
		return m.TaskId
	}
	return nil
}

// TasksReqponse contains the tasks requested.
type TasksResponse struct {
	Tasks []*Task `protobuf:"bytes,1,rep,name=tasks" json:"tasks,omitempty"`
}

func (m *TasksResponse) Reset()                    { *m = TasksResponse{} }
func (m *TasksResponse) String() string            { return proto1.CompactTextString(m) }
func (*TasksResponse) ProtoMessage()               {}
func (*TasksResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *TasksResponse) GetTasks() []*Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}

// QueuesRequest is sent to request a listing of all known queues.
type QueuesRequest struct {
	MatchPrefix []string `protobuf:"bytes,1,rep,name=match_prefix,json=matchPrefix" json:"match_prefix,omitempty"`
	MatchExact  []string `protobuf:"bytes,2,rep,name=match_exact,json=matchExact" json:"match_exact,omitempty"`
	Limit       int32    `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`
}

func (m *QueuesRequest) Reset()                    { *m = QueuesRequest{} }
func (m *QueuesRequest) String() string            { return proto1.CompactTextString(m) }
func (*QueuesRequest) ProtoMessage()               {}
func (*QueuesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *QueuesRequest) GetMatchPrefix() []string {
	if m != nil {
		return m.MatchPrefix
	}
	return nil
}

func (m *QueuesRequest) GetMatchExact() []string {
	if m != nil {
		return m.MatchExact
	}
	return nil
}

func (m *QueuesRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// QueuesResponse contains the requested list of queue statistics.
type QueuesResponse struct {
	Queues []*QueueStats `protobuf:"bytes,1,rep,name=queues" json:"queues,omitempty"`
}

func (m *QueuesResponse) Reset()                    { *m = QueuesResponse{} }
func (m *QueuesResponse) String() string            { return proto1.CompactTextString(m) }
func (*QueuesResponse) ProtoMessage()               {}
func (*QueuesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *QueuesResponse) GetQueues() []*QueueStats {
	if m != nil {
		return m.Queues
	}
	return nil
}

// TimeRequest asks the server for what it thinks is the current time.
type TimeRequest struct {
}

func (m *TimeRequest) Reset()                    { *m = TimeRequest{} }
func (m *TimeRequest) String() string            { return proto1.CompactTextString(m) }
func (*TimeRequest) ProtoMessage()               {}
func (*TimeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

// TimeResponse contains the server's idea of the current time in milliseconds
// since the epoch.
type TimeResponse struct {
	TimeMs int64 `protobuf:"varint,1,opt,name=time_ms,json=timeMs" json:"time_ms,omitempty"`
}

func (m *TimeResponse) Reset()                    { *m = TimeResponse{} }
func (m *TimeResponse) String() string            { return proto1.CompactTextString(m) }
func (*TimeResponse) ProtoMessage()               {}
func (*TimeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *TimeResponse) GetTimeMs() int64 {
	if m != nil {
		return m.TimeMs
	}
	return 0
}

func init() {
	proto1.RegisterType((*TaskID)(nil), "proto.TaskID")
	proto1.RegisterType((*TaskData)(nil), "proto.TaskData")
	proto1.RegisterType((*TaskChange)(nil), "proto.TaskChange")
	proto1.RegisterType((*Task)(nil), "proto.Task")
	proto1.RegisterType((*QueueStats)(nil), "proto.QueueStats")
	proto1.RegisterType((*ClaimRequest)(nil), "proto.ClaimRequest")
	proto1.RegisterType((*ClaimResponse)(nil), "proto.ClaimResponse")
	proto1.RegisterType((*ModifyRequest)(nil), "proto.ModifyRequest")
	proto1.RegisterType((*ModifyResponse)(nil), "proto.ModifyResponse")
	proto1.RegisterType((*ModifyDep)(nil), "proto.ModifyDep")
	proto1.RegisterType((*TasksRequest)(nil), "proto.TasksRequest")
	proto1.RegisterType((*TasksResponse)(nil), "proto.TasksResponse")
	proto1.RegisterType((*QueuesRequest)(nil), "proto.QueuesRequest")
	proto1.RegisterType((*QueuesResponse)(nil), "proto.QueuesResponse")
	proto1.RegisterType((*TimeRequest)(nil), "proto.TimeRequest")
	proto1.RegisterType((*TimeResponse)(nil), "proto.TimeResponse")
	proto1.RegisterEnum("proto.DepType", DepType_name, DepType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for EntroQ service

type EntroQClient interface {
	TryClaim(ctx context.Context, in *ClaimRequest, opts ...grpc.CallOption) (*ClaimResponse, error)
	Claim(ctx context.Context, in *ClaimRequest, opts ...grpc.CallOption) (*ClaimResponse, error)
	Modify(ctx context.Context, in *ModifyRequest, opts ...grpc.CallOption) (*ModifyResponse, error)
	Tasks(ctx context.Context, in *TasksRequest, opts ...grpc.CallOption) (*TasksResponse, error)
	Queues(ctx context.Context, in *QueuesRequest, opts ...grpc.CallOption) (*QueuesResponse, error)
	Time(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*TimeResponse, error)
}

type entroQClient struct {
	cc *grpc.ClientConn
}

func NewEntroQClient(cc *grpc.ClientConn) EntroQClient {
	return &entroQClient{cc}
}

func (c *entroQClient) TryClaim(ctx context.Context, in *ClaimRequest, opts ...grpc.CallOption) (*ClaimResponse, error) {
	out := new(ClaimResponse)
	err := grpc.Invoke(ctx, "/proto.EntroQ/TryClaim", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entroQClient) Claim(ctx context.Context, in *ClaimRequest, opts ...grpc.CallOption) (*ClaimResponse, error) {
	out := new(ClaimResponse)
	err := grpc.Invoke(ctx, "/proto.EntroQ/Claim", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entroQClient) Modify(ctx context.Context, in *ModifyRequest, opts ...grpc.CallOption) (*ModifyResponse, error) {
	out := new(ModifyResponse)
	err := grpc.Invoke(ctx, "/proto.EntroQ/Modify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entroQClient) Tasks(ctx context.Context, in *TasksRequest, opts ...grpc.CallOption) (*TasksResponse, error) {
	out := new(TasksResponse)
	err := grpc.Invoke(ctx, "/proto.EntroQ/Tasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entroQClient) Queues(ctx context.Context, in *QueuesRequest, opts ...grpc.CallOption) (*QueuesResponse, error) {
	out := new(QueuesResponse)
	err := grpc.Invoke(ctx, "/proto.EntroQ/Queues", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *entroQClient) Time(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*TimeResponse, error) {
	out := new(TimeResponse)
	err := grpc.Invoke(ctx, "/proto.EntroQ/Time", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for EntroQ service

type EntroQServer interface {
	TryClaim(context.Context, *ClaimRequest) (*ClaimResponse, error)
	Claim(context.Context, *ClaimRequest) (*ClaimResponse, error)
	Modify(context.Context, *ModifyRequest) (*ModifyResponse, error)
	Tasks(context.Context, *TasksRequest) (*TasksResponse, error)
	Queues(context.Context, *QueuesRequest) (*QueuesResponse, error)
	Time(context.Context, *TimeRequest) (*TimeResponse, error)
}

func RegisterEntroQServer(s *grpc.Server, srv EntroQServer) {
	s.RegisterService(&_EntroQ_serviceDesc, srv)
}

func _EntroQ_TryClaim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntroQServer).TryClaim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.EntroQ/TryClaim",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntroQServer).TryClaim(ctx, req.(*ClaimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EntroQ_Claim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntroQServer).Claim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.EntroQ/Claim",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntroQServer).Claim(ctx, req.(*ClaimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EntroQ_Modify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntroQServer).Modify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.EntroQ/Modify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntroQServer).Modify(ctx, req.(*ModifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EntroQ_Tasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntroQServer).Tasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.EntroQ/Tasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntroQServer).Tasks(ctx, req.(*TasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EntroQ_Queues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntroQServer).Queues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.EntroQ/Queues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntroQServer).Queues(ctx, req.(*QueuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EntroQ_Time_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntroQServer).Time(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.EntroQ/Time",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntroQServer).Time(ctx, req.(*TimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _EntroQ_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.EntroQ",
	HandlerType: (*EntroQServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TryClaim",
			Handler:    _EntroQ_TryClaim_Handler,
		},
		{
			MethodName: "Claim",
			Handler:    _EntroQ_Claim_Handler,
		},
		{
			MethodName: "Modify",
			Handler:    _EntroQ_Modify_Handler,
		},
		{
			MethodName: "Tasks",
			Handler:    _EntroQ_Tasks_Handler,
		},
		{
			MethodName: "Queues",
			Handler:    _EntroQ_Queues_Handler,
		},
		{
			MethodName: "Time",
			Handler:    _EntroQ_Time_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "entroq.proto",
}

func init() { proto1.RegisterFile("entroq.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 857 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x55, 0xdb, 0x6e, 0xdb, 0x46,
	0x10, 0x2d, 0xc5, 0x9b, 0x38, 0xba, 0x54, 0x5d, 0xbb, 0xa9, 0xe0, 0x22, 0x88, 0xb3, 0x68, 0x61,
	0x27, 0x05, 0xd2, 0x42, 0x85, 0x9f, 0x8a, 0x3e, 0x18, 0x16, 0xd1, 0x0a, 0xb0, 0x0c, 0x87, 0xd1,
	0x5b, 0x81, 0x2a, 0x5b, 0x71, 0x93, 0x10, 0xe1, 0xcd, 0xdc, 0x55, 0x12, 0x3f, 0xf6, 0xe7, 0xfa,
	0x11, 0xfd, 0x84, 0x7e, 0x45, 0x31, 0xbb, 0x4b, 0x8a, 0xb4, 0x15, 0x20, 0x79, 0xd2, 0xce, 0xfd,
	0xcc, 0xcc, 0x19, 0x0a, 0x86, 0x3c, 0x97, 0x55, 0x71, 0xf3, 0xac, 0xac, 0x0a, 0x59, 0x10, 0x57,
	0xfd, 0xd0, 0x19, 0x78, 0x2b, 0x26, 0xde, 0x2e, 0xe6, 0x64, 0x0c, 0xbd, 0x24, 0x9e, 0x5a, 0xc7,
	0xd6, 0x69, 0x10, 0xf5, 0x92, 0x98, 0x4c, 0xc1, 0x7f, 0xc7, 0x2b, 0x91, 0x14, 0xf9, 0xb4, 0x77,
	0x6c, 0x9d, 0xba, 0x51, 0x2d, 0xd2, 0x3f, 0xa0, 0x8f, 0x31, 0x73, 0x26, 0x19, 0x39, 0x04, 0xf7,
	0x66, 0xcb, 0xb7, 0xdc, 0x04, 0x6a, 0x81, 0x1c, 0x80, 0xcb, 0xe4, 0x3a, 0x13, 0x2a, 0xd2, 0x8e,
	0x1c, 0x26, 0x97, 0x02, 0x5d, 0xdf, 0xb1, 0x74, 0xcb, 0xa7, 0xf6, 0xb1, 0x75, 0x3a, 0x8c, 0xb4,
	0x60, 0xca, 0x3a, 0x75, 0x59, 0xfa, 0x27, 0x00, 0x26, 0xbf, 0x78, 0xc3, 0xf2, 0xd7, 0x9c, 0x7c,
	0x07, 0x5e, 0x91, 0xc6, 0x6b, 0x03, 0x6c, 0x30, 0x1b, 0x69, 0xf4, 0xcf, 0x34, 0xe6, 0xc8, 0x2d,
	0xd2, 0x78, 0x11, 0x93, 0xa7, 0xd0, 0xcf, 0xf9, 0xfb, 0x75, 0xcc, 0x24, 0x53, 0x15, 0x07, 0xb3,
	0x2f, 0x5b, 0x7e, 0x88, 0x33, 0xf2, 0x73, 0xfe, 0x1e, 0x1f, 0xf4, 0x3f, 0x0b, 0x1c, 0xd4, 0x7e,
	0x04, 0xb9, 0x86, 0xd3, 0xdb, 0x37, 0x05, 0xbb, 0x33, 0x85, 0x5d, 0x8f, 0x4e, 0xab, 0xc7, 0x47,
	0x30, 0xd8, 0xa4, 0x2c, 0xc9, 0x58, 0x2e, 0x11, 0xb4, 0xab, 0xf2, 0x40, 0xad, 0x5a, 0xc4, 0xbb,
	0x21, 0x78, 0xed, 0x21, 0x3c, 0x04, 0xd8, 0x54, 0x9c, 0x49, 0x1e, 0x63, 0x42, 0x5f, 0x25, 0x0c,
	0x8c, 0x46, 0x67, 0xcd, 0x8a, 0x38, 0x79, 0x95, 0x68, 0x7b, 0x5f, 0xd9, 0xa1, 0x56, 0x2d, 0x05,
	0x79, 0x00, 0x9e, 0xaa, 0x21, 0xa6, 0x81, 0x02, 0x69, 0x24, 0xfa, 0x2b, 0xc0, 0x73, 0x6c, 0xeb,
	0x85, 0x64, 0x52, 0x10, 0x02, 0x4e, 0xce, 0xb2, 0xba, 0x61, 0xf5, 0x26, 0xdf, 0x42, 0x90, 0x6f,
	0xb3, 0xb5, 0x64, 0xe2, 0xad, 0x30, 0x7b, 0xee, 0xe7, 0xdb, 0x0c, 0x27, 0x24, 0xe8, 0xdf, 0x16,
	0x0c, 0x2f, 0x30, 0x53, 0xc4, 0x6f, 0xb6, 0x5c, 0xc8, 0xbb, 0xed, 0x59, 0xf7, 0xda, 0x7b, 0x00,
	0x9e, 0x9a, 0x23, 0xe6, 0xb2, 0x4f, 0x83, 0xc8, 0x48, 0x18, 0x18, 0x6f, 0x2b, 0x26, 0x93, 0x22,
	0xc7, 0x0e, 0x6c, 0xdd, 0x41, 0xad, 0x5a, 0x0a, 0xf2, 0x0d, 0xf8, 0x65, 0x91, 0xa6, 0xbb, 0x79,
	0x7a, 0x28, 0x2e, 0x05, 0xfd, 0x09, 0x46, 0x06, 0x82, 0x28, 0x8b, 0x5c, 0x70, 0xf2, 0x08, 0x1c,
	0x44, 0x6b, 0x08, 0x31, 0x68, 0x2d, 0x3a, 0x52, 0x06, 0xfa, 0xaf, 0x05, 0xa3, 0x25, 0xce, 0xe6,
	0xf6, 0x93, 0x61, 0x3f, 0x01, 0x3f, 0xc9, 0x05, 0xaf, 0xa4, 0xc6, 0xbd, 0x8f, 0x3f, 0xc6, 0x4e,
	0x7e, 0x00, 0x7f, 0xa3, 0xb8, 0x89, 0x5d, 0xa0, 0xeb, 0x57, 0x2d, 0x57, 0xcd, 0xda, 0xa8, 0xf6,
	0x20, 0x27, 0xe0, 0xc7, 0x3c, 0xe5, 0x92, 0x63, 0x57, 0xf6, 0x7d, 0xfe, 0xd6, 0x56, 0xed, 0x58,
	0xf2, 0x3c, 0x16, 0x53, 0xf7, 0x23, 0x8e, 0xca, 0x4a, 0x5f, 0xc2, 0xb8, 0xee, 0xcd, 0xcc, 0xe3,
	0x04, 0xfa, 0x1a, 0x1b, 0xc7, 0xce, 0xec, 0xbb, 0x33, 0x69, 0x8c, 0xe4, 0xfb, 0x1a, 0x79, 0x6c,
	0x9a, 0xec, 0xf8, 0xd5, 0x36, 0xfa, 0x12, 0x02, 0x5d, 0x61, 0xce, 0x4b, 0x42, 0xc1, 0x91, 0xb7,
	0xa5, 0xa6, 0xcc, 0x78, 0x36, 0x36, 0x01, 0x73, 0x5e, 0xae, 0x6e, 0x4b, 0x1e, 0x29, 0x1b, 0x79,
	0xd8, 0x9c, 0xcc, 0x3d, 0xd8, 0x78, 0x41, 0x13, 0xb0, 0x33, 0xf1, 0x5a, 0xad, 0x3c, 0x88, 0xf0,
	0x49, 0x25, 0x0c, 0x15, 0xbf, 0x3e, 0x79, 0x3d, 0xcd, 0xa9, 0xf6, 0xda, 0xa7, 0x7a, 0x08, 0x6e,
	0x9a, 0x64, 0x89, 0x34, 0x87, 0xa9, 0x05, 0x24, 0x12, 0xb2, 0x60, 0xad, 0x3e, 0x2a, 0x8a, 0x82,
	0x28, 0x2e, 0x62, 0x3a, 0x83, 0x91, 0xa9, 0x6a, 0x06, 0xf7, 0x18, 0x5c, 0x4d, 0xfb, 0x3d, 0x53,
	0xd3, 0x16, 0x9a, 0xc0, 0x48, 0xdd, 0x4f, 0x03, 0xf5, 0x31, 0x0c, 0x33, 0x26, 0x37, 0x6f, 0xd6,
	0x65, 0xc5, 0x5f, 0x25, 0x1f, 0x54, 0x68, 0x10, 0x0d, 0x94, 0xee, 0x5a, 0xa9, 0xd4, 0xb1, 0x2a,
	0x17, 0xfe, 0x81, 0x6d, 0xa4, 0xb9, 0x03, 0x50, 0xaa, 0x10, 0x35, 0xfb, 0x71, 0xd3, 0x5f, 0x60,
	0x5c, 0x97, 0x32, 0xf8, 0x9e, 0x34, 0xb7, 0x64, 0x75, 0x88, 0xb6, 0xbb, 0xe8, 0xfa, 0xbc, 0xe8,
	0x08, 0x06, 0xab, 0x24, 0xe3, 0x06, 0x25, 0x3d, 0x81, 0xa1, 0x16, 0x4d, 0x26, 0x9c, 0x49, 0x92,
	0x71, 0x3c, 0x2e, 0x4b, 0x1f, 0x17, 0x8a, 0x4b, 0xf1, 0xf4, 0x1a, 0x7c, 0xb3, 0x4b, 0x12, 0x80,
	0x7b, 0x71, 0x79, 0xbe, 0x58, 0x4e, 0xbe, 0x20, 0x00, 0xde, 0x3c, 0xbc, 0x0c, 0x57, 0xe1, 0xc4,
	0xc2, 0xf7, 0xc5, 0xef, 0xe7, 0x57, 0xbf, 0x85, 0x93, 0x9e, 0xd6, 0x5f, 0x87, 0x57, 0xf3, 0x89,
	0xad, 0xdf, 0xab, 0xf3, 0xc5, 0xe5, 0xc4, 0xc1, 0xf7, 0xe2, 0xea, 0x45, 0x18, 0xad, 0x26, 0xee,
	0xec, 0x9f, 0x1e, 0x78, 0x21, 0xfe, 0xcf, 0x3c, 0x27, 0x67, 0xd0, 0x5f, 0x55, 0xb7, 0xea, 0x78,
	0xc9, 0x81, 0xc1, 0xde, 0xfe, 0x9a, 0x1c, 0x1d, 0x76, 0x95, 0x06, 0xec, 0x0c, 0xdc, 0xcf, 0x8e,
	0x39, 0x03, 0x4f, 0x73, 0x96, 0xd4, 0xf6, 0xce, 0x07, 0xe0, 0xe8, 0xeb, 0x3b, 0xda, 0x5d, 0x29,
	0x45, 0x89, 0xa6, 0x54, 0x9b, 0x96, 0x4d, 0xa9, 0x2e, 0x6b, 0xce, 0xc0, 0xd3, 0x7b, 0x6a, 0x4a,
	0x75, 0x18, 0xd2, 0x94, 0xba, 0xb3, 0xcc, 0x1f, 0xc1, 0xc1, 0x95, 0x10, 0x52, 0x27, 0xdd, 0xad,
	0xeb, 0xe8, 0xa0, 0xa3, 0xd3, 0x01, 0x7f, 0x79, 0x4a, 0xf7, 0xf3, 0xff, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x52, 0xea, 0x1d, 0xbe, 0xb6, 0x07, 0x00, 0x00,
}
